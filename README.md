# five-in-a-row

## 文件说明
WindowsProject/AI-arith.cpp //核心算法源文件
WindowsProject/AI-arith.h   //核心算法头文件
WindowsProject/main.cpp     //UI界面及主函数源文件
five-in-a-row.exe           //可执行文件：五子棋小游戏

## 运行环境
Windows Desktop Application
C++

## 设计思路
目标是实现一个五子棋人机博弈小游戏，游戏应满足以下条件：
-人执黑棋，计算机执白棋；
-左键落子，右键悔棋。

五子棋问题一般使用评估搜索法来求解。本次实验通过设计评估函数，基于对抗搜索和α-β剪枝算法，达到人机博弈的目的。
从空棋盘开始，每步行棋之后，将当前棋盘及其相关信息记录到一个状态state中，并以一个state为一个结点建立搜索树，以完成对下一步行棋位置的搜索和悔棋等操作。

## 核心算法
### 状态state的表示
上文已经提及，将一个时刻的棋盘及其相关信息记录为一个状态。这里定义一个类state，state的一个对象表示一个状态。其中二维数组CB[][]（ChessBoard）用于记录棋盘，黑棋（人，α-β剪枝算法中的MIN方）先手，用-1表示；白方（AI，α-β剪枝算法中的MAX方）后手，用1表示，空格用0表示。
state类中还封闭了其它一些信息和部分与状态相关的函数。
state的定义如下：
```
typedef class state {	//定义一个状态
public:
/* 该状态的基本信息 */
	int CB[15][15] = { 0 };	//ChessBoard：AI（MAX）1，对手（MIN）-1，空0
	int Last_i = -1;		//上一步横坐标
	int Last_j = -1;		//上一步纵坐标
	int eva = INT_MIN;	//用于存储其评价函数的值
/* 搜索树的建立 */
state* father;		//父结点
	vector<state*> child;//子结点（用容器存储）
/* α-β剪枝相关 */
int alpha = INT_MIN;
int beta = INT_MAX;
/* state类的成员函数 */
int F();			//评价函数
int GoalTest();	//目标测试函数：AI（MAX）胜返回1，对手（MIN）胜返回-1，其余返回0
state* minimax(int depth);	//极小极大值搜索：返回下一步行棋后的状态
	void clear();	//重新初始化其上一次搜索的临时数据
}state;
```

### 搜索树的建立
state中含有父结点指针father、子结点指针容器child，用于一个状态的父结点和子结点，用于搜索算法和悔棋操作。

### 评价函数的设计
由于对抗搜索和α-β剪枝算法本身已经相当明确，对于其具体流程这里就不再过多赘述。下面将重点分析α-β剪枝算法在五子棋博弈问题中的关键：评价函数的确定。
下面将对棋型进行分析，以保证评价函数的合理性。最常见的基本棋型大体有以下七种：连五，活四，冲四，活三，眠三，活二，眠二，下面将分别对这七种棋型进行评分。在实际情况中若黑、白棋子出现下列棋型，则评分分别按正、负计算即可。
1.**连五**：五颗棋子形成的棋型，五颗棋子连接。
连五的形成意味着胜负已分，因此评分应远高于其它棋型，设定为10000。
  -XXXXX
2.**活四**：四颗棋子形成的棋型，有两个连五点（即在两个位置落子均可以形成连五）。
活四的威胁性较大，一旦形成无法防守，因此评分设定为1000。
  -\*XXXX\*
3.**冲四**: 四颗棋子形成的棋型，有一个连五点。
冲四与活四相较而言威胁性较小，在唯一的连五点上落子即可防守，因此评分设定为100。
  -\*XXXXO
  -X\*XXX
  -XX\*XX
4.**活三**: 三颗棋子形成的棋型，有至少一个活四点，可以分为两种。
活三是五子棋进攻中最常见的一种棋型，从活三可以轻易转化为活四。对弈双方在面对活三时需要谨慎对待，若没有更好的进攻手段，需要进行防守，以防止活四的形成。将活三的评分设定为100。
5.**眠三**: 三颗棋子形成的棋型，仅存在冲四点，不存在活四点，可以分为六种。
眠三与活三相较而言威胁性较小，即使不防守也只能形成冲四，左右胜负的概率较小，因此评分设定为10。
6.**活二**: 两颗棋子形成的棋型，有至少一个活三点，可以分为三种。
活二的下一手能够形成活三，在某些时刻，特别是开局阶段，具有一定的威胁性，其评分设定为10。
7.**眠二**: 两颗棋子形成的棋型，有至少一个眠三点，可以分为四种。
眠二的威胁性较小，且一般在棋盘上大量存在，其对局势不易造成很大的影响，因此将其评分设定为1。




## 参考文献
[1] Stuart J. Russell，Peter Norvig．《人工智能：一种现代的方法（第3版）》[Ｍ]．北京：清华大学出版社，2013：64-95．
[2] marble_xu. Python五子棋AI实现(2):棋型评估函数实现[OL]. https://blog.csdn.net/marble_xu, 2019-05-23.
